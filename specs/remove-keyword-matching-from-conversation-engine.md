# Plan: Remove All Keyword-Matching & Fallbacks from Conversation Engine

## Executive Summary

Remove ALL hardcoded keyword matching, pattern detection, and fallback mechanisms from the conversation engine. All conversation logic must be driven by the AI agent through its system prompt, tools, and structured output schema. No Python code should contain keyword lists, regex-based routing, or hardcoded response templates that influence conversation flow.

## Current State Analysis

### 1. Knowledge Base Topic Detection (`knowledge/loader.py:52-99`)
**SEVERITY: HIGH** - Core keyword matching system
- `TOPIC_KEYWORDS` dictionary maps 11 topic IDs to ~100+ Russian/English keywords
- `detect_topics()` method does `keyword in message_lower` matching
- Used by `get_relevant_context()` to decide which knowledge base files to inject into prompt
- **Problem:** Keyword matching is brittle - misses synonyms, paraphrases, multi-word concepts

### 2. Hardcoded Wait-Word List (`agent_system_prompt.md:37-40`)
**SEVERITY: MEDIUM** - Hardcoded confirmation words in system prompt
- Lists: "Ð¾Ðº", "ok", "Ñ…Ð¾Ñ€Ð¾ÑˆÐ¾", "Ð¿Ð¾Ð½ÑÐ»", "Ð»Ð°Ð´Ð½Ð¾", "Ð¿Ñ€Ð¸Ð½ÑÐ»", "Ð´Ð°", "ÑƒÐ³Ñƒ", "Ð°Ð³Ð°"
- Emoji list: ðŸ‘, ðŸ‘Œ, âœ…, ðŸ™, ðŸ˜Š
- **Problem:** Agent should decide when to wait based on context, not keyword lists

### 3. Reasoning Leak Detection (`daemon.py:707-710, 1127-1128`)
**SEVERITY: MEDIUM** - Hardcoded pattern matching for safety
- `reasoning_patterns = ["ÐšÐ»Ð¸ÐµÐ½Ñ‚ ", "Ð­Ñ‚Ð¾ Ð·Ð°Ð¿Ñ€Ð¾Ñ", "schedule_followup", "Ð½ÑƒÐ¶Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ", "follow-up"]`
- Appears twice: in `_handle_schedule_followup()` and `execute_scheduled_action()`
- **Problem:** Fragile string matching for safety-critical detection

### 4. Phrase Templates (`temporal/phrase_tracker.py:12-42`)
**SEVERITY: HIGH** - Hardcoded greeting/opening/question templates
- `GREETING_TEMPLATES` (8 templates)
- `OPENING_PHRASES` (6 templates)
- `CLOSING_QUESTIONS` (7 templates)
- Used by `generate_initial_message()` in cli_agent.py to construct initial outreach
- **Problem:** Templates should be generated by the AI agent, not selected from hardcoded lists

### 5. Pause Greeting Templates (`temporal/pause_detector.py:116-122`)
**SEVERITY: MEDIUM** - Hardcoded pause greetings
- Transliterated Russian greetings for different pause durations
- `suggested_greeting` in ConversationGap is hardcoded text
- **Problem:** AI should generate contextually appropriate greetings

### 6. Fallback Time Expression Generation (`daemon.py:722-750`)
**SEVERITY: MEDIUM** - Hardcoded time-to-text conversion
- Minutes-based if/elif chain producing Russian time expressions
- Fallback when agent's confirmation message is rejected (reasoning leak)
- Days-of-week lookup: `days_ru = ["Ð² Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑŒÐ½Ð¸Ðº", "Ð²Ð¾ Ð²Ñ‚Ð¾Ñ€Ð½Ð¸Ðº", ...]`
- **Problem:** Should be generated by AI or at minimum handled as a formatting utility, not conversation logic

### 7. Media Type Text Placeholders (`daemon.py:827-837`)
**SEVERITY: LOW** - Media type to text conversion
- Maps media types to Russian text: `[Ð¤Ð¾Ñ‚Ð¾]`, `[Ð’Ð¸Ð´ÐµÐ¾]`, `[Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚]`
- This is a presentation layer concern, not conversation logic
- **Decision:** KEEP - this is pre-processing for the AI, not routing logic

### 8. Batch Detection Heuristic (`cli_agent.py:379`)
**SEVERITY: LOW** - String pattern detection
- `is_batch = "\n[" in incoming_message` - detects timestamped batch format
- **Decision:** KEEP - this is format detection, not conversation routing

### 9. Email Domain Typos (`scheduling/tool.py:21-60`)
**SEVERITY: LOW** - Email validation utility
- Domain typo mapping for common email providers
- **Decision:** KEEP - this is data validation, not conversation logic

### 10. Russian Month/Weekday Names (`scheduling/tool.py:62-87`)
**SEVERITY: NONE** - i18n constants
- **Decision:** KEEP - formatting utilities, not conversation logic

### 11. Escalation Keywords (`models.py:307`)
**SEVERITY: NONE** - Already disabled
- `escalation_keywords: list[str] = Field(default_factory=list)` - empty, noted as "Disabled - too many false positives"
- **Decision:** REMOVE the field entirely since it's disabled

## Files to Modify

| # | File | Change Type | Priority |
|---|------|-------------|----------|
| 1 | `src/telegram_sales_bot/knowledge/loader.py` | **MAJOR** - Replace keyword detection with AI-based topic detection | HIGH |
| 2 | `.claude/skills/telegram/config/agent_system_prompt.md` | **MEDIUM** - Remove hardcoded wait-word lists, make AI decide contextually | HIGH |
| 3 | `src/telegram_sales_bot/temporal/phrase_tracker.py` | **MAJOR** - Remove hardcoded templates, let AI generate all phrases | HIGH |
| 4 | `src/telegram_sales_bot/core/cli_agent.py` | **MEDIUM** - Remove PhraseTracker usage, simplify initial message generation | HIGH |
| 5 | `src/telegram_sales_bot/core/daemon.py` | **MEDIUM** - Remove reasoning leak patterns, remove fallback time expressions | MEDIUM |
| 6 | `src/telegram_sales_bot/temporal/pause_detector.py` | **MINOR** - Remove hardcoded greeting text, provide only gap metadata | MEDIUM |
| 7 | `src/telegram_sales_bot/core/models.py` | **MINOR** - Remove `escalation_keywords` field | LOW |

## Detailed Changes Per File

### 1. `knowledge/loader.py` - Replace Keyword Detection with AI Topic Selection

**Remove:**
- `TOPIC_KEYWORDS` dictionary (lines 52-99)
- `detect_topics()` method (lines 118-140)

**Replace with:**
- Simple method that loads ALL topic names + short descriptions
- Let the AI agent (via system prompt) decide which topics are relevant
- Provide a `get_all_topic_summaries()` method that returns topic ID -> name mapping
- The system prompt will include the list of available topics
- The agent schema gains an optional `relevant_topics` field for the AI to specify which KB topics to load
- Alternatively (simpler): always inject the master cheatsheet + provide topic list in prompt, let AI request specifics via a tool

**Chosen approach:** Simplest effective approach
- Always inject master cheatsheet (already happens)
- Add topic list with descriptions to system prompt
- Let the AI decide what's relevant naturally (it already has the conversation context)
- Remove keyword-based topic injection from `get_relevant_context()` - instead, inject broader context or let the agent request specifics
- For token efficiency: inject topic NAMES only, load full content on demand via system prompt instruction

### 2. `agent_system_prompt.md` - Remove Hardcoded Wait-Word Lists

**Remove:**
- Lines 37-40: The hardcoded lists of "Ð¾Ðº", "ok", etc. and emoji lists
- The prescriptive "if message contains X then wait" pattern

**Replace with:**
- Contextual instruction: "If the client sends a short acknowledgment without new information or questions, and you just asked them something they haven't answered yet, use action='wait'. Judge based on conversation context, not specific words."
- Add available topic list from knowledge base for AI-driven topic selection

### 3. `temporal/phrase_tracker.py` - Remove Hardcoded Templates

**Remove:**
- `GREETING_TEMPLATES` list (lines 12-21)
- `OPENING_PHRASES` list (lines 24-31)
- `CLOSING_QUESTIONS` list (lines 34-42)
- The entire `PhraseTracker` class and module

**Replace with:**
- Nothing. The AI agent generates all phrases naturally.
- Variety tracking (if needed) can be done by including used phrases in conversation history context, which already happens.

### 4. `cli_agent.py` - Remove PhraseTracker, Simplify Initial Message

**Remove:**
- Import of `PhraseTracker` (line 23)
- `generate_initial_message()`: Remove PhraseTracker usage, greeting/opening/question selection (lines 311-349)

**Replace with:**
- Simplified `generate_initial_message()` that passes prospect info to the AI and lets it craft the entire message
- The system prompt already contains tone-of-voice and communication methodology
- Include `used_greetings` list from prospect record in the prompt so AI avoids repetition naturally

### 5. `daemon.py` - Remove Reasoning Leak Patterns & Fallback Time Expressions

**Remove:**
- `reasoning_patterns` list and check in `_handle_schedule_followup()` (lines 705-710)
- `reasoning_patterns` list and check in `execute_scheduled_action()` (lines 1127-1132)
- Hardcoded time expression generation (lines 722-750): the `if minutes <= 5` chain and `days_ru` list
- Hardcoded fallback message template (line 1132): `"ÐŸÑ€Ð¸Ð²ÐµÑ‚! ÐšÐ°Ðº Ð¾Ð±ÐµÑ‰Ð°Ð»(Ð°), Ð¿Ð¸ÑˆÑƒ. {follow_up_intent or 'ÐšÐ°Ðº Ñƒ Ð²Ð°Ñ Ð´ÐµÐ»Ð°?'}"`

**Replace with:**
- For reasoning leak detection: Add a clear instruction in the system prompt that confirmation messages must be SHORT (1 sentence) and MUST NOT contain reasoning, analysis, or technical terms. If the agent's message exceeds a length threshold, ask the AI to regenerate (using a second CLI call with explicit instruction). This is more robust than keyword matching.
- For time expressions: Trust the agent to generate the confirmation. If the agent message is empty/None, use a simple fallback "Ð¥Ð¾Ñ€Ð¾ÑˆÐ¾, Ð½Ð°Ð¿Ð¸ÑˆÑƒ Ð¿Ð¾Ð·Ð¶Ðµ!" without trying to calculate natural time expressions in code.
- For the recursive schedule_followup in execute_scheduled_action: Trust the agent message or use a minimal generic fallback.

### 6. `pause_detector.py` - Remove Hardcoded Greetings

**Remove:**
- Hardcoded greeting strings (lines 116, 119, 122)

**Replace with:**
- Set `suggested_greeting = None` for all pause types
- The `ConversationGap` still provides useful metadata (pause_type, hours, last_message_from) which is passed to the AI via gap context
- The AI generates appropriate greetings based on the pause metadata

### 7. `models.py` - Clean Up Unused Field

**Remove:**
- `escalation_keywords` field (line 307)
- `escalation_notify` field (line 308) - if also unused in practice

**Note:** Check daemon.py for usage of escalation_notify before removing.

## Architecture After Changes

```
Incoming Message
    â”‚
    â–¼
[Media Detection] â”€â”€â”€â”€ (KEEP: pre-processing, not routing)
    â”‚
    â–¼
[Message Buffer] â”€â”€â”€â”€ (KEEP: timing/batching, not routing)
    â”‚
    â–¼
[Knowledge Context] â”€â”€â”€â”€ (CHANGED: always inject master cheatsheet + topic list in prompt)
    â”‚
    â–¼
[AI Agent via Claude CLI]
    â”‚ â”œâ”€â”€ System Prompt (tone, methodology, KB summary, available topics)
    â”‚ â”œâ”€â”€ Conversation History
    â”‚ â””â”€â”€ Current Message + Gap Metadata
    â”‚
    â–¼
[Structured JSON Output] â”€â”€â”€â”€ (action, message, reason, scheduling_data)
    â”‚
    â–¼
[Action Handler] â”€â”€â”€â”€ (SIMPLIFIED: no reasoning leak keyword checks)
    â”‚
    â”œâ”€â”€ reply â†’ Send message
    â”œâ”€â”€ wait â†’ Do nothing
    â”œâ”€â”€ check_availability â†’ Show slots
    â”œâ”€â”€ schedule â†’ Book meeting
    â”œâ”€â”€ schedule_followup â†’ Create scheduled action (trust agent's confirmation)
    â””â”€â”€ escalate â†’ Notify
```

## Migration Strategy

1. **Batch 1 (independent, parallel):**
   - `knowledge/loader.py` - Remove keyword detection
   - `temporal/phrase_tracker.py` - Remove hardcoded templates
   - `temporal/pause_detector.py` - Remove hardcoded greetings
   - `models.py` - Remove unused fields

2. **Batch 2 (depends on Batch 1):**
   - `agent_system_prompt.md` - Update system prompt (remove keyword lists, add topic context, strengthen AI instructions)
   - `cli_agent.py` - Remove PhraseTracker, simplify initial message generation

3. **Batch 3 (depends on Batch 2):**
   - `daemon.py` - Remove reasoning leak patterns and fallback generation

## Acceptance Criteria

1. No Python code contains keyword lists used for conversation routing/classification
2. No hardcoded response templates used for constructing messages sent to users
3. No if/elif chains that match specific words to actions
4. All message content is generated by the AI agent
5. Topic detection for knowledge base is removed (broader context injection instead)
6. PhraseTracker module is removed entirely
7. Pause detector provides only metadata, no text suggestions
8. Reasoning leak detection uses length/simplicity heuristics instead of keyword matching
9. The bot still functions correctly with all existing actions (reply, wait, schedule, etc.)
10. System prompt is updated to guide the AI to make all decisions it previously delegated to code
